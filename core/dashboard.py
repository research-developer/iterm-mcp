"""
HTML Dashboard server for iTerm MCP multi-agent orchestration.

Provides:
- Static file serving (HTML, CSS, JS)
- SSE /events endpoint for real-time updates
- Auto-generation of iterm2:// URL handler scripts
"""

import asyncio
import json
import logging
import os
import stat
from pathlib import Path
from typing import Any, Callable, Dict, Optional, TYPE_CHECKING
from urllib.parse import unquote, urlparse

if TYPE_CHECKING:
    from core.terminal import ItermTerminal
    from utils.telemetry import TelemetryEmitter

logger = logging.getLogger(__name__)

# MIME types for static files
MIME_TYPES = {
    ".html": "text/html; charset=utf-8",
    ".css": "text/css; charset=utf-8",
    ".js": "application/javascript; charset=utf-8",
    ".json": "application/json; charset=utf-8",
    ".png": "image/png",
    ".svg": "image/svg+xml",
    ".ico": "image/x-icon",
}

# Script templates for iterm2:// URL handlers
FOCUS_SCRIPT_TEMPLATE = '''#!/bin/bash
# Auto-generated by iterm-mcp dashboard
# Focus an agent's terminal pane
AGENT_NAME="$1"

if [ -z "$AGENT_NAME" ]; then
    echo "Usage: iterm-mcp-focus <agent-name>"
    exit 1
fi

# Use it2api if available, otherwise fall back to Python API
if command -v it2api &> /dev/null; then
    # Get session ID for agent (requires agent registry lookup)
    it2api activate-session "$AGENT_NAME" 2>/dev/null || \\
        echo "Could not focus agent: $AGENT_NAME"
else
    python3 -c "
import asyncio
import sys
sys.path.insert(0, '{project_root}')
from core.agents import AgentRegistry
from core.terminal import ItermTerminal
import iterm2

async def main():
    registry = AgentRegistry()
    agent = registry.get_agent('$AGENT_NAME')
    if not agent:
        print(f'Agent not found: $AGENT_NAME')
        return

    conn = await iterm2.Connection.async_create()
    app = await iterm2.async_get_app(conn)
    for window in app.terminal_windows:
        for tab in window.tabs:
            for session in tab.sessions:
                if session.session_id == agent.session_id:
                    await session.async_activate()
                    await tab.async_select()
                    await window.async_activate()
                    print(f'Focused agent: $AGENT_NAME')
                    return
    print(f'Session not found for agent: $AGENT_NAME')

asyncio.run(main())
"
fi
'''

SEND_SCRIPT_TEMPLATE = '''#!/bin/bash
# Auto-generated by iterm-mcp dashboard
# Send a command to an agent's terminal pane
AGENT_NAME="$1"
shift
COMMAND="$@"

if [ -z "$AGENT_NAME" ] || [ -z "$COMMAND" ]; then
    echo "Usage: iterm-mcp-send <agent-name> <command...>"
    exit 1
fi

python3 -c "
import asyncio
import sys
sys.path.insert(0, '{project_root}')
from core.agents import AgentRegistry
import iterm2

async def main():
    registry = AgentRegistry()
    agent = registry.get_agent('$AGENT_NAME')
    if not agent:
        print(f'Agent not found: $AGENT_NAME')
        return

    conn = await iterm2.Connection.async_create()
    app = await iterm2.async_get_app(conn)
    for window in app.terminal_windows:
        for tab in window.tabs:
            for session in tab.sessions:
                if session.session_id == agent.session_id:
                    await session.async_send_text('$COMMAND\\n')
                    print(f'Sent to $AGENT_NAME: $COMMAND')
                    return
    print(f'Session not found for agent: $AGENT_NAME')

asyncio.run(main())
"
'''


class DashboardServer:
    """HTTP server for the visual dashboard with SSE support."""

    def __init__(
        self,
        telemetry: "TelemetryEmitter",
        terminal: "ItermTerminal",
        notification_manager: Optional[Any] = None,
        port: int = 9999,
        static_dir: Optional[Path] = None,
    ):
        self.telemetry = telemetry
        self.terminal = terminal
        self.notification_manager = notification_manager
        self.port = port
        self.static_dir = static_dir or self._default_static_dir()
        self._server: Optional[asyncio.AbstractServer] = None
        self._sse_clients: list = []
        self._update_interval = 1.0  # seconds between SSE updates
        self._running = False

    def _default_static_dir(self) -> Path:
        """Get the default static directory path."""
        # Relative to this file: ../static/
        return Path(__file__).parent.parent / "static"

    async def start(self, duration: int = 0) -> str:
        """
        Start the dashboard server.

        Args:
            duration: How long to run in seconds (0 = indefinitely)

        Returns:
            Status message with dashboard URL
        """
        if self._server:
            return f"Dashboard already running at http://localhost:{self.port}"

        self._running = True
        self._server = await asyncio.start_server(
            self._handle_connection,
            "0.0.0.0",
            self.port,
        )

        # Start SSE broadcast task
        asyncio.create_task(self._broadcast_loop())

        # Generate URL handler scripts
        await self._generate_url_handlers()

        msg = f"Dashboard running at http://localhost:{self.port}"
        logger.info(msg)

        if duration > 0:
            asyncio.create_task(self._auto_shutdown(duration))
            msg += f" (will stop after {duration}s)"

        return msg

    async def stop(self) -> None:
        """Stop the dashboard server."""
        self._running = False
        if self._server:
            self._server.close()
            await self._server.wait_closed()
            self._server = None

        # Close all SSE clients
        for client in self._sse_clients:
            try:
                client.close()
            except Exception:
                pass
        self._sse_clients.clear()

        logger.info("Dashboard server stopped")

    async def _auto_shutdown(self, duration: int) -> None:
        """Automatically shutdown after duration seconds."""
        await asyncio.sleep(duration)
        await self.stop()

    async def _handle_connection(
        self,
        reader: asyncio.StreamReader,
        writer: asyncio.StreamWriter,
    ) -> None:
        """Handle an incoming HTTP connection."""
        try:
            # Read request line
            request_line = await asyncio.wait_for(
                reader.readline(),
                timeout=5.0,
            )
            if not request_line:
                return

            request_str = request_line.decode("utf-8", errors="ignore").strip()
            parts = request_str.split()
            if len(parts) < 2:
                return

            method, path = parts[0], parts[1]

            # Read headers
            headers = {}
            while True:
                header_line = await reader.readline()
                if header_line in (b"\r\n", b"\n", b""):
                    break
                try:
                    key, value = header_line.decode().strip().split(":", 1)
                    headers[key.lower()] = value.strip()
                except ValueError:
                    continue

            # Parse URL
            parsed = urlparse(path)
            url_path = unquote(parsed.path)

            # Parse query string
            query_params = {}
            if parsed.query:
                for param in parsed.query.split("&"):
                    if "=" in param:
                        k, v = param.split("=", 1)
                        query_params[unquote(k)] = unquote(v)

            # Route request
            if url_path == "/events":
                await self._handle_sse(writer)
            elif url_path == "/api/state":
                await self._handle_api_state(writer)
            elif url_path == "/api/focus":
                await self._handle_focus(writer, query_params)
            elif url_path == "/api/send":
                await self._handle_send(writer, query_params, reader, headers)
            else:
                await self._handle_static(url_path, writer)

        except asyncio.TimeoutError:
            logger.debug("Connection timeout")
        except Exception as e:
            logger.debug(f"Connection error: {e}")
        finally:
            try:
                writer.close()
                await writer.wait_closed()
            except Exception:
                pass

    async def _handle_static(
        self,
        path: str,
        writer: asyncio.StreamWriter,
    ) -> None:
        """Serve static files."""
        # Default to index.html
        if path == "/" or path == "":
            path = "/dashboard.html"

        # Security: prevent directory traversal
        safe_path = Path(path).name if ".." in path else path.lstrip("/")
        file_path = self.static_dir / safe_path

        if not file_path.exists() or not file_path.is_file():
            await self._send_response(writer, 404, "text/plain", b"Not Found")
            return

        # Determine content type
        suffix = file_path.suffix.lower()
        content_type = MIME_TYPES.get(suffix, "application/octet-stream")

        # Read and send file
        content = file_path.read_bytes()
        await self._send_response(writer, 200, content_type, content)

    async def _handle_api_state(self, writer: asyncio.StreamWriter) -> None:
        """Handle /api/state endpoint - returns current dashboard state."""
        try:
            await self.terminal.get_sessions()
            state = await self._get_dashboard_state()
            body = json.dumps(state, indent=2, default=str).encode()
            await self._send_response(writer, 200, "application/json", body)
        except Exception as e:
            logger.error(f"Error getting state: {e}")
            body = json.dumps({"error": str(e)}).encode()
            await self._send_response(writer, 500, "application/json", body)

    async def _handle_focus(
        self,
        writer: asyncio.StreamWriter,
        params: Dict[str, str],
    ) -> None:
        """Handle /api/focus?agent=<name> - focus an agent's pane."""
        agent_name = params.get("agent")
        if not agent_name:
            body = json.dumps({"error": "Missing 'agent' parameter"}).encode()
            await self._send_response(writer, 400, "application/json", body)
            return

        try:
            # Get agent from registry
            agent = self.telemetry.agent_registry.get_agent(agent_name)
            if not agent:
                body = json.dumps({"error": f"Agent not found: {agent_name}"}).encode()
                await self._send_response(writer, 404, "application/json", body)
                return

            # Focus the session using terminal's focus_session method
            await self.terminal.get_sessions()
            await self.terminal.focus_session(agent.session_id)

            body = json.dumps({"success": True, "message": f"Focused: {agent_name}"}).encode()
            await self._send_response(writer, 200, "application/json", body)
            logger.info(f"Focused agent: {agent_name}")

        except Exception as e:
            logger.error(f"Error focusing agent {agent_name}: {e}")
            body = json.dumps({"error": str(e)}).encode()
            await self._send_response(writer, 500, "application/json", body)

    async def _handle_send(
        self,
        writer: asyncio.StreamWriter,
        params: Dict[str, str],
        reader: asyncio.StreamReader,
        headers: Dict[str, str],
    ) -> None:
        """Handle /api/send?agent=<name>&command=<cmd> - send command to agent."""
        agent_name = params.get("agent")
        command = params.get("command", "")

        # For POST requests, read command from body
        if not command and headers.get("content-length"):
            content_length = int(headers.get("content-length", 0))
            if content_length > 0:
                body_data = await reader.read(content_length)
                try:
                    body_json = json.loads(body_data.decode())
                    command = body_json.get("command", "")
                except json.JSONDecodeError:
                    command = body_data.decode()

        if not agent_name:
            body = json.dumps({"error": "Missing 'agent' parameter"}).encode()
            await self._send_response(writer, 400, "application/json", body)
            return

        if not command:
            body = json.dumps({"error": "Missing 'command' parameter"}).encode()
            await self._send_response(writer, 400, "application/json", body)
            return

        try:
            # Get agent from registry
            agent = self.telemetry.agent_registry.get_agent(agent_name)
            if not agent:
                body = json.dumps({"error": f"Agent not found: {agent_name}"}).encode()
                await self._send_response(writer, 404, "application/json", body)
                return

            # Find the session
            await self.terminal.get_sessions()
            session = self.terminal.sessions.get(agent.session_id)
            if not session:
                body = json.dumps({"error": f"Session not found for agent: {agent_name}"}).encode()
                await self._send_response(writer, 404, "application/json", body)
                return

            # Send the command
            await session.send_text(command + "\n")

            body = json.dumps({"success": True, "message": f"Sent to {agent_name}: {command}"}).encode()
            await self._send_response(writer, 200, "application/json", body)
            logger.info(f"Sent to {agent_name}: {command}")

        except Exception as e:
            logger.error(f"Error sending to agent {agent_name}: {e}")
            body = json.dumps({"error": str(e)}).encode()
            await self._send_response(writer, 500, "application/json", body)

    async def _handle_sse(self, writer: asyncio.StreamWriter) -> None:
        """Handle SSE /events endpoint."""
        # Send SSE headers
        headers = (
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/event-stream\r\n"
            "Cache-Control: no-cache\r\n"
            "Connection: keep-alive\r\n"
            "Access-Control-Allow-Origin: *\r\n"
            "\r\n"
        )
        writer.write(headers.encode())
        await writer.drain()

        self._sse_clients.append(writer)
        logger.debug(f"SSE client connected. Total: {len(self._sse_clients)}")

        try:
            # Refresh sessions and send initial state
            await self.terminal.get_sessions()
            await self._send_sse_event(writer, await self._get_dashboard_state())

            # Keep connection alive until client disconnects
            while self._running:
                try:
                    # Send keep-alive comment every 15 seconds
                    writer.write(b": keepalive\n\n")
                    await writer.drain()
                    await asyncio.sleep(15)
                except (ConnectionResetError, BrokenPipeError):
                    break
        finally:
            if writer in self._sse_clients:
                self._sse_clients.remove(writer)
            logger.debug(f"SSE client disconnected. Total: {len(self._sse_clients)}")

    async def _broadcast_loop(self) -> None:
        """Broadcast state updates to all SSE clients."""
        last_state = None

        while self._running:
            try:
                await asyncio.sleep(self._update_interval)

                if not self._sse_clients:
                    continue

                # Get current state
                await self.terminal.get_sessions()
                state = await self._get_dashboard_state()

                # Only broadcast if state changed
                state_json = json.dumps(state, sort_keys=True, default=str)
                if state_json == last_state:
                    continue
                last_state = state_json

                # Broadcast to all clients
                disconnected = []
                for client in self._sse_clients:
                    try:
                        await self._send_sse_event(client, state)
                    except (ConnectionResetError, BrokenPipeError):
                        disconnected.append(client)

                # Remove disconnected clients
                for client in disconnected:
                    if client in self._sse_clients:
                        self._sse_clients.remove(client)

            except Exception as e:
                logger.debug(f"Broadcast error: {e}")
                await asyncio.sleep(1)

    async def _send_sse_event(
        self,
        writer: asyncio.StreamWriter,
        data: Dict[str, Any],
    ) -> None:
        """Send an SSE event to a client."""
        payload = json.dumps(data, default=str)
        event = f"data: {payload}\n\n"
        writer.write(event.encode())
        await writer.drain()

    async def _get_dashboard_state(self) -> Dict[str, Any]:
        """Get the current dashboard state with agent info."""
        state = self.telemetry.dashboard_state(self.terminal)

        # Add agent details
        agents = []
        for agent in self.telemetry.agent_registry.list_agents():
            agents.append({
                "name": agent.name,
                "session_id": agent.session_id,
                "teams": list(agent.teams) if agent.teams else [],
                "role": agent.role or "general",
                "status": self._get_agent_status(agent),
            })
        state["agents"] = agents

        # Add notifications if available
        if self.notification_manager:
            notifications = await self.notification_manager.get(limit=20)
            state["notifications"] = [
                {
                    "id": str(id(n)),
                    "agent": n.agent,
                    "level": n.level.value if hasattr(n.level, "value") else n.level,
                    "summary": n.summary,
                    "timestamp": n.timestamp.isoformat() if hasattr(n.timestamp, "isoformat") else str(n.timestamp),
                }
                for n in notifications
            ]
        else:
            state["notifications"] = []

        return state

    def _get_agent_status(self, agent: Any) -> str:
        """Determine an agent's status based on session state."""
        try:
            session = self.terminal.sessions.get(agent.session_id)
            if not session:
                return "offline"
            if getattr(session, "is_processing", False):
                return "busy"
            return "idle"
        except Exception:
            return "unknown"

    async def _send_response(
        self,
        writer: asyncio.StreamWriter,
        status: int,
        content_type: str,
        body: bytes,
    ) -> None:
        """Send an HTTP response."""
        status_text = {200: "OK", 404: "Not Found", 500: "Internal Server Error"}.get(
            status, "Unknown"
        )
        response = (
            f"HTTP/1.1 {status} {status_text}\r\n"
            f"Content-Type: {content_type}\r\n"
            f"Content-Length: {len(body)}\r\n"
            "Connection: close\r\n"
            "\r\n"
        ).encode() + body
        writer.write(response)
        await writer.drain()

    async def _generate_url_handlers(self) -> None:
        """Generate shell scripts for iterm2:// URL handling."""
        bin_dir = Path.home() / ".iterm-mcp" / "bin"
        bin_dir.mkdir(parents=True, exist_ok=True)

        project_root = str(Path(__file__).parent.parent)

        # Generate focus script
        focus_script = bin_dir / "iterm-mcp-focus"
        focus_script.write_text(
            FOCUS_SCRIPT_TEMPLATE.format(project_root=project_root)
        )
        focus_script.chmod(focus_script.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP)

        # Generate send script
        send_script = bin_dir / "iterm-mcp-send"
        send_script.write_text(
            SEND_SCRIPT_TEMPLATE.format(project_root=project_root)
        )
        send_script.chmod(send_script.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP)

        logger.info(f"Generated URL handler scripts in {bin_dir}")
        logger.info(
            f"Add to PATH: export PATH=\"$PATH:{bin_dir}\""
        )


# Global dashboard instance
_dashboard_server: Optional[DashboardServer] = None


async def start_dashboard(
    telemetry: "TelemetryEmitter",
    terminal: "ItermTerminal",
    notification_manager: Optional[Any] = None,
    port: int = 9999,
    duration: int = 0,
) -> str:
    """
    Start the dashboard server.

    Args:
        telemetry: TelemetryEmitter instance
        terminal: ItermTerminal instance
        notification_manager: Optional NotificationManager for notifications
        port: Port to listen on (default 9999)
        duration: How long to run in seconds (0 = indefinitely)

    Returns:
        Status message with dashboard URL
    """
    global _dashboard_server

    if _dashboard_server:
        await _dashboard_server.stop()

    _dashboard_server = DashboardServer(
        telemetry=telemetry,
        terminal=terminal,
        notification_manager=notification_manager,
        port=port,
    )

    return await _dashboard_server.start(duration=duration)


async def stop_dashboard() -> None:
    """Stop the dashboard server."""
    global _dashboard_server
    if _dashboard_server:
        await _dashboard_server.stop()
        _dashboard_server = None
